---
title: "Advanced indexing & Broadcasting"
subtitle: "Lecture 06"
author: "Dr. Colin Rundel"
footer: "Sta 663 - Spring 2025"
format:
  revealjs:
    theme: slides.scss
    transition: fade
    slide-number: true
    self-contained: true
execute:
  echo: true
---

```{r, message=FALSE, warning=FALSE, include=FALSE}
options(
  width=80
)

local({
  hook_old <- knitr::knit_hooks$get("error")  # save the old hook
  knitr::knit_hooks$set(error = function(x, options) {
    x = sub("## \n## Detailed traceback:\n.*$", "", x)
    x = sub("Error in py_call_impl\\(.*?\\)\\: ", "", x)
    hook_old(x, options)
  })
})
```

```{python include=FALSE}
import numpy as np

np.set_printoptions(edgeitems=3, linewidth=180)
```






# Broadcasting

## Broadcasting

This is an approach for deciding how to generalize arithmetic operations between arrays with differing shapes.

```{python}
x = np.array([1, 2, 3])
x * 2
x * np.array([2])
x * np.array([2,2,2])
```

In the first example `2` is equivalent to the array `np.array([2])` which is being broadcast across the longer array `x`.

## Efficiancy

Using broadcasts can be much more efficient as it does not copy the underlying data,

```{python eval = FALSE}
x = np.arange(1e5)
y = np.array([2]).repeat(1e5)
```

```python
%timeit x * 2
17.3 µs ± 101 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)
```

```python
%timeit x * np.array([2])
17.2 µs ± 239 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)
```

```python
%timeit x * y
36 µs ± 121 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each)
```

## General Broadcasting

> When operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing (i.e. rightmost) dimensions and works its way left. Two dimensions are compatible when
>
>    1. they are equal, or
>
>    2. one of them is 1
> 
> If these conditions are not met, a `ValueError: operands could not be broadcast together` exception is thrown, indicating that the arrays have incompatible shapes. The size of the resulting array is the size that is not 1 along each axis of the inputs.

## Example

Why does the code on the left work but not the code on the right?

:::: {.columns .small}
::: {.column width='50%'}
```{python}
x = np.arange(12).reshape((4,3))
x

x + np.array([1,2,3])
```
:::

::: {.column width='50%'}
```{python error=TRUE}
x = np.arange(12).reshape((3,4))
x

x + np.array([1,2,3])
```
:::
::::

. . .

:::: {.columns}
::: {.column width='50%'}
```
x    (2d array): 4 x 3
y    (1d array):     3 
----------------------
x+y  (2d array): 4 x 3
```
:::

::: {.column width='50%'}
```
x    (2d array): 3 x 4
y    (1d array):     3 
----------------------
x+y  (2d array): Error
```
:::
::::



## A quick fix

```{python error=TRUE}
x = np.arange(12).reshape((3,4)); x
x + np.array([1,2,3]).reshape(3,1)
```

. . .

```
x    (2d array): 3 x 4
y    (2d array): 3 x 1
----------------------
x+y  (2d array): 3 x 4
```

## Examples (2)

:::: {.columns}
::: {.column width='50%'}
```{python}
x = np.arange(12).reshape((4,3))
y = 1
x+y
```

```
x    (2d array): 4 x 3
y    (1d array):     1 
----------------------
x+y  (2d array): 4 x 3
```
:::

::: {.column width='50%' .fragment}
```{python}
x = np.arange(12).reshape((4,3))
y = np.array([1,2,3])
x+y
```


```
x    (2d array): 4 x 3
y    (1d array):     3 
----------------------
x+y  (2d array): 4 x 3
```
:::
::::


## Examples (3)

::: {.small}
```{python}
x = np.array([0,10,20,30]).reshape((4,1))
y = np.array([1,2,3])
```
:::

:::: {.columns .small}
::: {.column width='50%'}
```{python}
x
y
```
:::

::: {.column width='50%'}

```{python}
x+y
```
:::
::::

. . .

![](imgs/numpy_broadcasting.png){fig-align="center" width="50%"}

::: {.aside}
From NumPy user guide - [Broadcasting](https://numpy.org/doc/stable/user/basics.broadcasting.html)
:::

## Exercise 3

For each of the following combinations determine what the resulting dimension will be using broadcasting

* A [128 x 128 x 3] + B [3]

* A [8 x 1 x 6 x 1] + B [7 x 1 x 5]

* A [2 x 1] + B [8 x 4 x 3]

* A [3 x 1] + B [15 x 3 x 5]

* A [3] + B [4]


## Demo 1 - Standardization

Below we generate a data set with 3 columns of random normal values. Each column has a different mean and standard deviation which we can check with `mean()` and `std()`.

```{python}
rng = np.random.default_rng(1234)
d = rng.normal(loc=[-1,0,1], scale=[1,2,3], size=(1000,3))
```

```{python}
d.mean(axis=0)
d.std(axis=0)
```

Use broadcasting to standardize all three columns to have mean 0 and standard deviation 1. 

Check the new data set using `mean()` and `std()`.


## Broadcasting and assignment

In addition to arithmetic operators, broadcasting can be used with assignment via array indexing,

```{python error=TRUE}
x = np.arange(12).reshape((3,4))
y = -np.arange(4)
z = -np.arange(3)
```

:::: {.columns}
::: {.column width='50%'}
```{python}
x[:] = y
x
x[...] = y
x
```
:::

::: {.column width='50%'}
```{python error=TRUE}
x[:] = z
x[:] = z.reshape((3,1))
x
```
:::
::::



# Basic file IO

## Reading and writing ndarrays

We will not spend much time on this as most data you will encounter is more likely to be a tabular format (e.g. data frame) and tools like Pandas are more appropriate.

For basic saving and loading of NumPy arrays there are the `save()` and `load()` functions which use a built in binary format.

```{python}
x = np.arange(1e5)

np.save("data/x.npy", x)

new_x = np.load("data/x.npy")

np.all(x == new_x)
```

Additional functions for saving (`savez()`, `savez_compressed()`, `savetxt()`) exist for saving multiple arrays or saving a text representation of an array.

## Reading delimited data

While not particularly recommended, if you need to read delimited (csv, tsv, etc.) data into a NumPy array you can use `genfromtxt()`,

```{r include=FALSE}
options(width=300)
```

::: {.small}
```{python}
with open("data/mtcars.csv") as file:
    mtcars = np.genfromtxt(file, delimiter=",", skip_header=True)
    
mtcars
```
:::
